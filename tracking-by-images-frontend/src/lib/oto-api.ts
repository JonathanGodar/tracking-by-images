// Code generated by oto; DO NOT EDIT.

// HeadersFunc allows you to mutate headers for each request.
// Useful for adding authorization into the client.
interface HeadersFunc {
	(headers: Headers): void;
}

// Client provides access to remote services.
export class Client {
	// basepath is the path prefix for the requests.
	// This may be a path, or an absolute URL.
	public basepath: String = '/oto/'
	// headers allows calling code to mutate the HTTP
	// headers of the underlying HTTP requests.
	public headers?: HeadersFunc
}


export class TrackerService {
	constructor(readonly client: Client) {}
	
		async addTracker(addTrackerRequest?: AddTrackerRequest, modifyHeaders?: HeadersFunc): Promise<AddTrackerResponse> {
		if (addTrackerRequest == null) {
			
				addTrackerRequest = new AddTrackerRequest();
			
		}

		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'TrackerService.AddTracker', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(addTrackerRequest),
		})
		if (response.status !== 200) {
			throw new Error(`TrackerService.AddTracker: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new AddTrackerResponse(json);
		})
	}
	
		async deleteTracker(string?: string, modifyHeaders?: HeadersFunc): Promise<DeleteTrackerResponse> {
		if (string == null) {
			
				string = "";
			
		}

		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'TrackerService.DeleteTracker', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(string),
		})
		if (response.status !== 200) {
			throw new Error(`TrackerService.DeleteTracker: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new DeleteTrackerResponse(json);
		})
	}
	
		async updateTracker(updateTrackerRequest?: UpdateTrackerRequest, modifyHeaders?: HeadersFunc): Promise<UpdateTrackerResponse> {
		if (updateTrackerRequest == null) {
			
				updateTrackerRequest = new UpdateTrackerRequest();
			
		}

		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'TrackerService.UpdateTracker', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(updateTrackerRequest),
		})
		if (response.status !== 200) {
			throw new Error(`TrackerService.UpdateTracker: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new UpdateTrackerResponse(json);
		})
	}
	
}

export class UserService {
	constructor(readonly client: Client) {}
	
		async addUser(addUserRequest?: AddUserRequest, modifyHeaders?: HeadersFunc): Promise<AddUserResponse> {
		if (addUserRequest == null) {
			
				addUserRequest = new AddUserRequest();
			
		}

		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'UserService.AddUser', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(addUserRequest),
		})
		if (response.status !== 200) {
			throw new Error(`UserService.AddUser: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new AddUserResponse(json);
		})
	}
	
		async getAccessToken(getAccessTokenRequest?: GetAccessTokenRequest, modifyHeaders?: HeadersFunc): Promise<GetAccessTokenResponse> {
		if (getAccessTokenRequest == null) {
			
				getAccessTokenRequest = new GetAccessTokenRequest();
			
		}

		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'UserService.GetAccessToken', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(getAccessTokenRequest),
		})
		if (response.status !== 200) {
			throw new Error(`UserService.GetAccessToken: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new GetAccessTokenResponse(json);
		})
	}
	
		async getMe(object?: object, modifyHeaders?: HeadersFunc): Promise<GetMeResponse> {
		if (object == null) {
			
				object = {}; 
			
		}

		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'UserService.GetMe', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(object),
		})
		if (response.status !== 200) {
			throw new Error(`UserService.GetMe: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new GetMeResponse(json);
		})
	}
	
}



  
	export class AddTrackerRequest {
		constructor(data?: any) {
			if (data) {
			
				
				  
				  this.ownerID = data.ownerID;
				  
				
			
				
				  
				  this.isActive = data.isActive;
				  
				
			
			}
		}
	
			ownerID: string = stringDefault;
	
			isActive: boolean = booleanDefault;
	
	}
  

  
	export class AddTrackerResponse {
		constructor(data?: any) {
			if (data) {
			
				
				  
					  
						  this.tracker = new models.Tracker(data.tracker);
					  
				  
				
			
				
				  
				  this.error = data.error;
				  
				
			
			}
		}
	
			tracker?: models.Tracker;
	
		// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;
	
	}
  

  
	export class AddUserRequest {
		constructor(data?: any) {
			if (data) {
			
				
				  
				  this.email = data.email;
				  
				
			
				
				  
				  this.password = data.password;
				  
				
			
			}
		}
	
			email: string = stringDefault;
	
			password: string = stringDefault;
	
	}
  

  
	export class AddUserResponse {
		constructor(data?: any) {
			if (data) {
			
				
				  
					  
						  this.user = new models.User(data.user);
					  
				  
				
			
				
				  
				  this.error = data.error;
				  
				
			
			}
		}
	
			user?: models.User;
	
		// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;
	
	}
  

  
	export class DeleteTrackerResponse {
		constructor(data?: any) {
			if (data) {
			
				
				  
				  this.error = data.error;
				  
				
			
			}
		}
	
		// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;
	
	}
  

  
	export class GetAccessTokenRequest {
		constructor(data?: any) {
			if (data) {
			
				
				  
				  this.email = data.email;
				  
				
			
				
				  
				  this.password = data.password;
				  
				
			
			}
		}
	
			email: string = stringDefault;
	
			password: string = stringDefault;
	
	}
  

  
	export class GetAccessTokenResponse {
		constructor(data?: any) {
			if (data) {
			
				
				  
				  this.token = data.token;
				  
				
			
				
				  
				  this.error = data.error;
				  
				
			
			}
		}
	
			token: string = stringDefault;
	
		// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;
	
	}
  

  
	export class GetMeResponse {
		constructor(data?: any) {
			if (data) {
			
				
				  
					  
						  this.user = new models.User(data.user);
					  
				  
				
			
				
				  
				  this.error = data.error;
				  
				
			
			}
		}
	
			user?: models.User;
	
		// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;
	
	}
  

  
	export class Tracker {
		constructor(data?: any) {
			if (data) {
			
				
				  
				  this.id = data.id;
				  
				
			
				
				  
				  this.times_accessed = data.times_accessed;
				  
				
			
				
				  
				  this.owner_id = data.owner_id;
				  
				
			
				
				  
				  this.url = data.url;
				  
				
			
				
				  
				  this.is_active = data.is_active;
				  
				
			
				
			
				
			
			}
		}
	
			id: string = stringDefault;
	
			times_accessed: number = numberDefault;
	
			owner_id: string = stringDefault;
	
			url: string = stringDefault;
	
			is_active: boolean = booleanDefault;
	
			-?: models.trackerR;
	
			-?: models.trackerL;
	
	}
  

  
	export class UpdateTrackerRequest {
		constructor(data?: any) {
			if (data) {
			
				
				  
				  this.id = data.id;
				  
				
			
				
				  
				  this.isActive = data.isActive;
				  
				
			
			}
		}
	
			id: string = stringDefault;
	
			isActive: boolean = booleanDefault;
	
	}
  

  
	export class UpdateTrackerResponse {
		constructor(data?: any) {
			if (data) {
			
				
				  
					  
						  this.tracker = new models.Tracker(data.tracker);
					  
				  
				
			
				
				  
				  this.error = data.error;
				  
				
			
			}
		}
	
			tracker?: models.Tracker;
	
		// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;
	
	}
  

  
	export class User {
		constructor(data?: any) {
			if (data) {
			
				
				  
				  this.id = data.id;
				  
				
			
				
				  
				  this.email = data.email;
				  
				
			
				
			
				
			
				
			
			}
		}
	
			id: string = stringDefault;
	
			email: string = stringDefault;
	
			-: string = stringDefault;
	
			-?: models.userR;
	
			-?: models.userL;
	
	}
  

  
	export class trackerL {
		constructor(data?: any) {
			if (data) {
			
			}
		}
	
	}
  

  
	export class trackerR {
		constructor(data?: any) {
			if (data) {
			
				
				  
					  
						  this.Owner = new models.User(data.Owner);
					  
				  
				
			
			}
		}
	
			Owner?: models.User;
	
	}
  

  
	export class userL {
		constructor(data?: any) {
			if (data) {
			
			}
		}
	
	}
  

  
	export class userR {
		constructor(data?: any) {
			if (data) {
			
				
				  
				  this.OwnerTrackers = data.OwnerTrackers;
				  
				
			
			}
		}
	
			OwnerTrackers: models.TrackerSlice = models.TrackerSliceDefault;
	
	}
  


// these defaults make the template easier to write.
const stringDefault = ''
const numberDefault = 0
const booleanDefault = false 
const anyDefault = null
